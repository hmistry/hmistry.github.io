<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://hmistry.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://hmistry.github.io/" rel="alternate" type="text/html" /><updated>2026-01-13T07:12:45+00:00</updated><id>http://hmistry.github.io/feed.xml</id><title type="html">Hiren Mistry</title><subtitle>This is my personal blog where I write about my projects.
</subtitle><entry><title type="html">Why Smart Thermostats Still Struggle — and How Room-Level Sensing Finally Fixed My Home</title><link href="http://hmistry.github.io/home-diy/2026/01/08/smart-thermostat-controller.html" rel="alternate" type="text/html" title="Why Smart Thermostats Still Struggle — and How Room-Level Sensing Finally Fixed My Home" /><published>2026-01-08T00:00:00+00:00</published><updated>2026-01-08T00:00:00+00:00</updated><id>http://hmistry.github.io/home-diy/2026/01/08/smart-thermostat-controller</id><content type="html" xml:base="http://hmistry.github.io/home-diy/2026/01/08/smart-thermostat-controller.html"><![CDATA[<p>Most residential forced-air HVAC systems struggle with uneven heating and cooling — not because of bad equipment, but because they lack the sensing and control needed to adapt to real-world conditions inside a home.</p>

<p>After years of dealing with hot and cold rooms in a home with two-zone forced-air HVAC system, I built a custom room-sensing thermostat controller to address the root causes with a budget-friendly cost structure. After ten months of daily use, the home has been noticeably more comfortable, with only a modest increase in energy usage.</p>

<p>This post explains why most thermostat designs fall short and what worked better in practice.</p>

<!--more-->

<h2 id="problem-thermal-airflow-poor-sensing-and-no-dynamic-control">Problem: Thermal airflow, poor sensing, and no dynamic control</h2>

<h4 id="scenario">Scenario</h4>

<p><img src="/assets/images/HVAC-Home-Heat-Flow.png" alt="HVAC House Heat Flow Example" /></p>

<p>Consider above example of a two-zone home:</p>

<ul>
  <li>One thermostat controls the downstairs (T1)</li>
  <li>Another controls the upstairs (T2)</li>
  <li>Zone dampers control hot/cold airflow between zones</li>
  <li>A single HVAC unit serves both zones</li>
  <li>One-sided solar heat gain</li>
</ul>

<p>Factors contributing to uneven heat distribution in this example are:</p>

<ol>
  <li>Open floor plan zones lose effectiveness as heated or cooled air quickly flows to the return vent, limiting heat transfer to the space.</li>
  <li>One-sided solar heat gain creates uneven temperatures within a zone, making control decisions ambiguous.</li>
  <li>Inter-zone thermal coupling causes heating in one zone to affect thermostats in another (i.e. heating downstairs affects T2 thermostat).</li>
  <li>Poor thermostat placement results in measurements that do not reflect actual living spaces.</li>
  <li>Room door and window states vary constantly, changing the room’s airflow and heat loss.</li>
  <li>Vent adjustments are static and cannot adapt to weather, occupancy, or airflow changes.</li>
  <li>Room-sensor averaging can mask cold rooms, delaying heating.</li>
  <li>Lack of historical data makes it difficult to understand thermal behavior in the home and tune the HVAC system.</li>
</ol>

<h2 id="design-solution-control-where-comfort-is-actually-needed">Design Solution: Control Where Comfort is Actually Needed</h2>

<p>The key insight was simple:</p>

<ol>
  <li>Thermostat control decisions should be based on room-level temperature data, not hallway averages. In practice, temperature does not equalize quickly enough to rely on averaging.</li>
  <li>The thermostat control strategy must be customizable and allow algorithms beyond simple averaging.</li>
</ol>

<h4 id="architecture">Architecture</h4>

<p><img src="/assets/images/HVAC-Architecture-Proposed.png" alt="HVAC Design Solution" /></p>

<p>The solution consists of:</p>

<ul>
  <li>Low-cost Bluetooth temperature sensors placed in each room</li>
  <li>Home Assistant running on a Raspberry Pi 5 handles all the control logic</li>
  <li>An ESP32-based HVAC zone controller managing dampers, HVAC furnace, and A/C Condenser</li>
  <li>Custom algorithms to optimize heating and cooling for comfort</li>
</ul>

<p>How it works:</p>

<ul>
  <li>Bluetooth Temperature sensors can be placed in ideal locations in each room, sending temperature and humidity data to Home Assistant</li>
  <li>The ESP32 HVAC Zone Controller is connected to zone dampers, HVAC furnace, and A/C Condenser.</li>
  <li>HVAC Zone Controller is setup to run the following:
    <ul>
      <li>Cycles: Off, Heat, Cool, Fan, Purge</li>
      <li>Zones: All, Upstairs, Downstairs</li>
      <li>Safe operations: ensure correct sequencing and timing requirements between cycles and zones are met</li>
    </ul>
  </li>
  <li>Created a HVAC Dashboard in Home Assistant with all the necessary thermostat controls and data per zone.</li>
  <li>Use automations to ensure selected room temperatures in a zone stay within a range, e.g. 70-73°F during the winter (heat only) and 80-83°F in the summer (cool only). Instead of averaging room temperatures, the automation evaluates the minimum and maximum room temperatures in a zone and calls for heating or cooling when any prioritized room moves below or above the defined range respectively*.</li>
</ul>

<p><em>*There are some edge cases that require additional logic to the algorithm. However, for the purposes of this article, this is the core strategy.</em></p>

<h4 id="hardware">Hardware</h4>

<p><img src="/assets/images/Xiaomi-RPi-ESP.jpg" alt="Xiaomi Sensors + Raspberry Pi + ESP32 Controller" /></p>

<h4 id="home-assistant-thermostat-ui">Home Assistant Thermostat UI</h4>

<p><img src="/assets/images/HA-Thermostats.png" alt="HA Thermostats" /></p>

<h2 id="results">Results</h2>

<h4 id="room-temperature-charts">Room Temperature Charts</h4>

<p><img src="/assets/images/HA-Charts-Temp.png" alt="HA HVAC Temperature Charts" /></p>

<h4 id="hvac-runtime-charts">HVAC Runtime Charts</h4>

<p><img src="/assets/images/HA-Usage-Charts.png" alt="HA HVAC Usage Charts" /></p>

<p>I implemented the above solution with 9 Temperature sensors including 1 outside and it’s been running for 10 months now. Here’s the results so far:</p>

<ol>
  <li>Much Better Comfort
    <ul>
      <li>Prioritized room temperature variations dropped from several degrees to roughly 3°F during regulated periods. Cold and hot bedrooms largely disappeared.</li>
      <li>Sometimes large temperature differences between rooms from solar heat gain occur that require some user intervention (i.e. close/open room doors &amp; windows) to help close the gap quicker and allow the system to operate normally for rest of the night.</li>
    </ul>
  </li>
  <li>Inter-Zone Coupling Eliminated
    <ul>
      <li>Heating downstairs no longer interferes with upstairs heating. Bedroom temperatures now drive decisions instead of hallway temperature.</li>
    </ul>
  </li>
  <li>Data-Driven HVAC Tuning
    <ul>
      <li>Temperature data helped identify airflow imbalances and adjusted vents accordingly</li>
      <li>Runtime data helped optimize energy consumption by heating one zone at a time</li>
    </ul>
  </li>
  <li>Stable HVAC Operation
    <ul>
      <li>No short cycling of HVAC furnace or A/C condenser</li>
      <li>Purge cycles happen after each run</li>
      <li>Correct sequencing, timing, and safeguards enforced</li>
    </ul>
  </li>
  <li>Modest Energy Impact
    <ul>
      <li>Energy usage increased by approximately 10–20%, but comfort improved significantly. For the first time, the home maintained consistent, comfortable temperatures throughout the day.</li>
    </ul>
  </li>
  <li>Cheaper than commercial solutions
    <ul>
      <li>9 Temperature sensors ($36) + Raspberry Pi 5 ($140) + ESP32 x8 Relay Board ($44) = $220</li>
      <li>Compared to an Ecobee (2x$120) + 6 Room sensors ($240) + Zone Controller ($150) = $630</li>
      <li>Adding temperature sensors is cheap at $4 each</li>
    </ul>
  </li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>Many of the comfort issues I had lived with for years—hot and cold rooms, overheated hallways, and slow recovery from afternoon solar heat gain—turned out to be artifacts of poor sensing and overly simple control logic. I was surprised by how effective room-level sensing and a window-based control strategy turned out to be, and the experience has changed how I think about residential HVAC systems. The biggest gains did not come from adding AI, machine learning, or fancy hardware, but from giving the system better inputs and using the right control logic to respond to real conditions instead of averaged data. The secondary benefit is a better cost structure by unifying the controller and for scaling sensing in a home.</p>

<p>This solution is not a silver bullet. It still requires occasional user intervention when there are large temperature differences between rooms, as well as some technical knowledge to build and maintain. But after ten months of use, it has delivered a level of comfort that commercial thermostats never achieved in my home, and it reinforces a simple idea: comfort improves when control decisions are made closer to where people actually live.</p>

<h2 id="references">References</h2>

<ul>
  <li>For in-depth details on implementation and results, see <a href="https://github.com/hmistry/smart-thermostat-controller/blob/main/smart_thermostat_controller_design.md">Smart Thermostat Controller Design and Results</a></li>
  <li>Other project information is available in <a href="https://github.com/hmistry/smart-thermostat-controller">Smart Thermostat Controller Github repository</a></li>
</ul>]]></content><author><name></name></author><category term="home-diy" /><category term="home-assistant" /><category term="smart-thermostat" /><category term="hvac" /><category term="raspberry-pi" /><summary type="html"><![CDATA[Most residential forced-air HVAC systems struggle with uneven heating and cooling — not because of bad equipment, but because they lack the sensing and control needed to adapt to real-world conditions inside a home. After years of dealing with hot and cold rooms in a home with two-zone forced-air HVAC system, I built a custom room-sensing thermostat controller to address the root causes with a budget-friendly cost structure. After ten months of daily use, the home has been noticeably more comfortable, with only a modest increase in energy usage. This post explains why most thermostat designs fall short and what worked better in practice.]]></summary></entry><entry><title type="html">Home Assistant: Lessons Learned</title><link href="http://hmistry.github.io/home-diy/2025/12/15/home-assistant-lessons.html" rel="alternate" type="text/html" title="Home Assistant: Lessons Learned" /><published>2025-12-15T00:00:00+00:00</published><updated>2025-12-15T00:00:00+00:00</updated><id>http://hmistry.github.io/home-diy/2025/12/15/home-assistant-lessons</id><content type="html" xml:base="http://hmistry.github.io/home-diy/2025/12/15/home-assistant-lessons.html"><![CDATA[<p>My first 3 months of using Home Assistant (HA) on a Raspberry Pi 5 were unreliable: frequent database corruption, failed boots and data loss. After researching and addressing the root causes, Home Assistant has now been stable and running smoothly for 6+ months.</p>

<p>Below are my experience-based tips that may help you build a stable Home Assistant platform.</p>

<!--more-->

<ol>
  <li>
    <p>SD Card → SSD (Most Important Fix)</p>

    <ul>
      <li>Problem:
        <ul>
          <li>SD cards failed repeatedly once backups exceeded ~100 MB</li>
          <li>Resulted in database file corruption and failed boots</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Avoid SD cards entirely for long-term HA installs</li>
          <li>Use a NVMe SSD for main disk</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>SQLite → MariaDB (Second Most Important Fix)</p>

    <ul>
      <li>Problem:
        <ul>
          <li>SQLite database corruption occurred frequently</li>
          <li>Unsure whether root cause was SD card I/O, SQLite itself, or bad (entity) data</li>
          <li>Lost historical data multiple times and had to start fresh</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Switch recorder to MariaDB (HA add-on)</li>
          <li>Much more stable, even with large backup sizes and data migrations during updates</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Backups (Off-Device) (Third Most Important Thing)</p>

    <ul>
      <li>Problem:
        <ul>
          <li>On-device backups don’t help when storage fails or file corruption occurs</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Back up frequently</li>
          <li>Download backups off the HA disk periodically</li>
          <li>Download and store backup encryption key off-device, see <code class="language-plaintext highlighter-rouge">Settings → System → Backup → Configure Backup Settings → Download Emergency Kit</code></li>
          <li>Worst-case you minimize data loss to your most recent backup or easily restore all the devices, integrations, and configurations for a fresh start</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>“Disable → Change → Enable” Strategy For Modifying Entities</p>

    <ul>
      <li>Problem:
        <ul>
          <li>Modifying or deleting entities while active sometimes preceded DB issues</li>
          <li>Using uninitialized entities in templates caused unpredictable behavior</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Disable entities before modifying or deleting</li>
          <li>Re-enable after changes made and allow time for update events if applicable</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Be Patient With Boot / Shutdown</p>

    <ul>
      <li>Problem:
        <ul>
          <li>HA appears “hung” during boot or shutdown</li>
          <li>Power-cycling too early made things worse by increasing file corruption risk</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Wait several minutes for Raspberry Pi to shutdown processes or boot up</li>
          <li>Raspberry Pi is not a high-performance computer</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>HA Upgrades Can Fail On Reboot</p>

    <ul>
      <li>Problem:
        <ul>
          <li>Failed boots after HA upgrades</li>
          <li>Components with custom logic can fail on reboot after due to missing or uninitialized states</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Backup before every upgrade (download to off-device)</li>
          <li>Harden custom logic/formulas against uninitialized, unknown, unavailable, none, or null states (see this <a href="https://community.home-assistant.io/t/how-to-handle-unknown-or-unavailable-states-in-template-entities-or-automations/411632/15">post on states</a>)</li>
          <li>Use the Template Editor under <code class="language-plaintext highlighter-rouge">Developer Tools → Template</code> to test your formulas or state values</li>
          <li>Check <code class="language-plaintext highlighter-rouge">Developer Tools → Statistics</code> and fix any issues</li>
          <li>Check logs for any critical errors before and after upgrading under <code class="language-plaintext highlighter-rouge">Settings → System → Logs</code> and select the services/add-ons in the dropdown button</li>
          <li>Use “Disable → change → enable” strategy when modifying entities</li>
          <li>Sometimes starting fresh (without importing bad historical data) is necessary</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Always Validate Changes to <code class="language-plaintext highlighter-rouge">configuration.yaml</code></p>

    <ul>
      <li>Problem:
        <ul>
          <li>Invalid YAML configuration can prevent HA from booting</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Run “Check Configuration” under <code class="language-plaintext highlighter-rouge">Developer Tools → YAML → Check Configuration</code> after making changes and before restarting HA</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Clear Cache to Fix Broken Dashboards</p>

    <ul>
      <li>Problem:
        <ul>
          <li>Energy, Logs, or History pages fail to load but other dashboard works</li>
        </ul>
      </li>
      <li>Fix:
        <ul>
          <li>Test dashboard in a private browser window</li>
          <li>If it works, clear caches</li>
          <li>Desktop browser: hard reload / clear cache</li>
          <li>iOS app: <code class="language-plaintext highlighter-rouge">Settings → Debug → Reset Frontend Cache</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Pairing Bluetooth Keyboard / Mouse via CLI to RPi</p>

    <ul>
      <li>Reference: <a href="https://www.youtube.com/watch?v=UEmSsscijKE">Pairing Bluetooth Devices</a></li>
      <li>
        <p>Shell Commands used:</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># On your computer terminal</span>
ssh pi@raspberrypi.local

<span class="c"># On the Raspberry Pi</span>
<span class="nb">sudo </span>bluetoothctl
agent on
default agent
scan on
<span class="c"># Wait for device address</span>
scan off
devices <span class="c"># To print list of devices found and their addresses</span>
<span class="c"># Replace AA:BB:CC:DD:EE:FF with your device address below</span>
pair AA:BB:CC:DD:EE:FF
connect AA:BB:CC:DD:EE:FF
trust AA:BB:CC:DD:EE:FF <span class="c"># Allows RPi to trust device and reconnect on reboot</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>NVMe SSD Installation</p>

    <ul>
      <li>References:
        <ul>
          <li><a href="https://warmestrobot.com/blog/2024/06/27/raspberry-pi-network-boot-guide-2/">Raspberry Pi Boot Guide</a></li>
          <li><a href="https://www.martinrowan.co.uk/2024/02/installing-home-assistant-on-raspberry-pi-5-nvme-storage/">HA install on Raspberry Pi 5 with NVMe SSD</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Recover Files From a Failed HAOS Boot and No Off-Device Backup</p>

    <ul>
      <li>Notes
        <ul>
          <li>Credits to HA community forum contributors for the solution (sorry, I lost the link to where I found it)</li>
          <li>You can recover all the config files or on-device backups if you have the encryption key to unlock it on restore</li>
          <li><a href="https://community.home-assistant.io/t/home-assistant-addon-filebrowser/282108">FileBrowser add-on</a>: GUI File browser</li>
          <li><a href="https://github.com/hassio-addons/addon-ssh">Advanced SSH &amp; Terminal add-on</a>: SSH Terminal</li>
        </ul>
      </li>
      <li>Steps:
        <ol>
          <li>Original HA SD card fails to boot - put aside</li>
          <li>Use a new SD card and install a fresh copy of Home Assistant on it</li>
          <li>Put the new SD card in Raspberry Pi and setup new HA instance (no restoring backups)</li>
          <li>Install Advanced SSH/Terminal and FileBrowser add-ons</li>
          <li>Config SSH/Terminal and disable protection mode</li>
          <li>Insert failed SD card via USB port on Raspberry Pi</li>
          <li>Wait for notification in Settings saying multiple HAOS detected… make note of the USB path eg /dev/sda8 but do not fix</li>
          <li>
            <p>In HA SSH Terminal, do the following:</p>

            <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># login to correct container shell to access usb</span>
<span class="nb">sudo </span>docker <span class="nb">exec</span> <span class="nt">-it</span> homeassistant /bin/bash
<span class="nb">mkdir</span> /config/tmp <span class="c"># create a tmp folder</span>
mount /dev/sda8 /config/tmp <span class="c"># mount SD card usb to tmp folder</span>
<span class="c"># =&gt; now you can browse files on bad SD card in FileBrowser under the mounted folder /config/tmp</span>

<span class="c"># To copy files over to new SD card HAOS:</span>
<span class="nb">cd</span> /config
<span class="nb">mkdir </span>old_data
<span class="nb">cp</span> <span class="nt">-r</span> /config/tmp/supervisor old_data/
<span class="c"># =&gt; now all the files from the bad SD card are in the new HAOS /config/old_data</span>

<span class="c"># unmount USB</span>
umount /config/tmp
<span class="nb">exit</span> <span class="c"># exits the docker bash shell and brings you back to your terminal shell</span>
</code></pre></div>            </div>
          </li>
          <li>Use FileBrowser to download /config/old_data</li>
          <li>Re-enable SSH/Terminal protection mode</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h2 id="summary">Summary</h2>

<p>What ultimately stabilized my Home Assistant setup:</p>

<ul>
  <li>SSD instead of SD card</li>
  <li>MariaDB instead of SQLite</li>
  <li>Defensive entity handling strategy</li>
  <li>Hardened custom logic/formula use in components</li>
  <li>Taking precautions when upgrading and having backup copies</li>
</ul>

<p>Now Home Assistant behaves like a reliable system!</p>]]></content><author><name></name></author><category term="home-diy" /><category term="home-assistant" /><category term="raspberry-pi" /><summary type="html"><![CDATA[My first 3 months of using Home Assistant (HA) on a Raspberry Pi 5 were unreliable: frequent database corruption, failed boots and data loss. After researching and addressing the root causes, Home Assistant has now been stable and running smoothly for 6+ months. Below are my experience-based tips that may help you build a stable Home Assistant platform.]]></summary></entry><entry><title type="html">Using CDN to improve file uploads</title><link href="http://hmistry.github.io/software/2020/09/29/using-cdn-to-improve-uploads.html" rel="alternate" type="text/html" title="Using CDN to improve file uploads" /><published>2020-09-29T00:00:00+00:00</published><updated>2020-09-29T00:00:00+00:00</updated><id>http://hmistry.github.io/software/2020/09/29/using-cdn-to-improve-uploads</id><content type="html" xml:base="http://hmistry.github.io/software/2020/09/29/using-cdn-to-improve-uploads.html"><![CDATA[<p>For one of my client projects, I explored different ways to increase upload speeds for large files uploaded from a desktop computer to AWS S3. The desktop computer was located in a different country, halfway around the world, with a throttled/restrictive outbound internet connection to the S3 storage located in the US region. One approach is doing parallel uploads but the focus was on how to get a faster connection.</p>

<p>I discovered 3 ways to architect file uploads to AWS S3:
<!--more--></p>

<ol>
  <li>
    <p>Standard mode
In this mode, you setup a bucket in S3 in a specified region with all the default settings and the client uploads the files to the S3 region directly no matter where the client is located in the world. This is the most simplest setup. The file upload speed will greatly depend on quality of the entire connection and ping times will depend on the distance to the storage.</p>
  </li>
  <li>
    <p>S3 Accelerated mode
You create a bucket like you normally do in #1 above but you check the box for file acceleration. This allows a client device to connect to the nearest S3 location and then uses the AWS hi-speed backbone connection to the specified S3 bucket region. The upload speed will depend on the quality of the connection between the client and the nearest S3 location as we can assume AWS inter-region connection is a high bandwidth pipe that won’t be the limiting factor. You might experience slights delays for S3 to synchronize files between regions. This is very easy to implement however there are additional costs (see AWS S3 pricing) to use this.</p>
  </li>
  <li>
    <p>Using Cloudfront or a CDN as an edge location
This was an interesting idea and a different use case of a CDN. A CDN is normally used to cache assets so clients all the world will have a closer location to download the assets resulting in faster download times. However instead of using a CDN to cache asset files for clients to download, we can use it as an edge location for client devices to connect to, and then transport the stream to the specified S3 location using larger high bandwidth connections. It is essentially the same as #2 above, but you’re not limited to S3 locations and CDN’s can have more locations for clients to connect to. The CDN does not buffer or store the file, it is simply allowing the data stream to pass through it to the end destination. There are additional costs to using CDN’s and the setup is more involved requiring knowledge on how to configure the CDN and AWS to accept connections from it.</p>
  </li>
</ol>

<h3 id="results">Results</h3>

<p>Unfortunately, none of these solutions resulted in any significant speed improvements over the standard mode (#1) most likely due to the country where the desktop computer was located. Also, AWS did not own any servers located in that country and as such the restrictive outbound connection to the nearest S3 location or CDN was probably the bottleneck.</p>

<p>However if we were doing file uploads in a different country that didn’t have a restrictive outbound connection, I think the S3 Accelerated mode or using the CDN method would have resulted in a potential improvement in upload speeds and is worth exploring.</p>]]></content><author><name></name></author><category term="software" /><category term="ruby" /><category term="performance" /><summary type="html"><![CDATA[For one of my client projects, I explored different ways to increase upload speeds for large files uploaded from a desktop computer to AWS S3. The desktop computer was located in a different country, halfway around the world, with a throttled/restrictive outbound internet connection to the S3 storage located in the US region. One approach is doing parallel uploads but the focus was on how to get a faster connection. I discovered 3 ways to architect file uploads to AWS S3:]]></summary></entry><entry><title type="html">Writing a Git Commit Message</title><link href="http://hmistry.github.io/software/2018/02/18/writing-a-git-commit-message.html" rel="alternate" type="text/html" title="Writing a Git Commit Message" /><published>2018-02-18T00:00:00+00:00</published><updated>2018-02-18T00:00:00+00:00</updated><id>http://hmistry.github.io/software/2018/02/18/writing-a-git-commit-message</id><content type="html" xml:base="http://hmistry.github.io/software/2018/02/18/writing-a-git-commit-message.html"><![CDATA[<p>This is a summary of Chris Beams’ post on <a href="https://chris.beams.io/posts/git-commit/">“How to Write a Git Commit Message”</a> for the purpose of being my quick reference. (As Chris mentions: “This has all been said before” - see his references.)</p>

<p><br /></p>
<h3 id="guidelines">Guidelines</h3>
<ol>
  <li><a href="#separate">Separate subject from body with a blank line</a></li>
  <li><a href="#limit">Limit the subject line to 50 characters, with hard limit at 72</a></li>
  <li><a href="#capitalize">Capitalize the subject line</a></li>
  <li><a href="#period">Do not end the subject line with a period</a></li>
  <li><a href="#imperative">Use the imperative mood in the subject line</a></li>
  <li><a href="#wrap">Wrap the body at 72 characters</a></li>
  <li><a href="#body">Use the body to explain <em>what and why</em> vs. <em>how</em></a>
<!--more--></li>
</ol>

<p><br /></p>
<h4 id="separate">1. Separate subject from body with a blank line</h4>
<ul>
  <li>Blank line separation is needed for some Git commands to work better in short form</li>
  <li>Use a text editor instead of the CLI -m option. To setup an editor for use with Git CLI, see <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration">this section of Pro Git</a>.</li>
</ul>

<p><br /></p>
<h4 id="limit">2. Limit the subject line to 50 characters, with hard limit at 72</h4>
<ul>
  <li>GitHub’s UI truncates any subject line longer than 72 characters with an ellipsis</li>
  <li>Git log one-liner or shortlog works better with approx 50 chars</li>
</ul>

<p><br /></p>
<h4 id="capitalize">3. Capitalize the subject line</h4>

<p><br /></p>
<h4 id="period">4. Do not end the subject line with a period</h4>

<p><br /></p>
<h4 id="imperative">5. Use the imperative mood in the subject line</h4>
<ul>
  <li>Imperative mood means “spoken or written as if giving a command or instruction” e.g. clean your room, or close the door</li>
  <li>A Git commit subject line should be able to complete the following sentence:
    <ul>
      <li>If applied, this commit will <strong><em>your subject line here</em></strong></li>
      <li>If applied, this commit will <em>refactor subsystem X for readability</em></li>
    </ul>
  </li>
</ul>

<p><br /></p>
<h4 id="wrap">6. Wrap the body at 72 characters</h4>

<p><br /></p>
<h4 id="body">7. Use the body to explain <em>what and why</em> vs. <em>how</em></h4>
<ul>
  <li>Focus on clarifying the reasons why you made the change in the first place — <em>the way things worked before the change and what was wrong with that</em>, <em>the way they work now</em>, and <em>why you decided to solve it the way you did</em>.</li>
</ul>

<p><br /></p>
<h4 id="commit-template">Commit template</h4>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">Summarize changes <span class="k">in </span>around 50 characters or less

More detailed explanatory text, <span class="k">if </span>necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical <span class="o">(</span>unless
you omit the body entirely<span class="o">)</span><span class="p">;</span> various tools like <span class="sb">`</span>log<span class="sb">`</span>, <span class="sb">`</span>shortlog<span class="sb">`</span>
and <span class="sb">`</span>rebase<span class="sb">`</span> can get confused <span class="k">if </span>you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how <span class="o">(</span>the code explains that<span class="o">)</span><span class="nb">.</span>
Are there side effects or other unintuitive consequences of this
change? Here is the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used <span class="k">for </span>the bullet, preceded
   by a single space, with blank lines <span class="k">in </span>between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: <span class="c">#123</span>
See also: <span class="c">#456, #789</span></code></pre></figure>]]></content><author><name></name></author><category term="software" /><category term="git" /><summary type="html"><![CDATA[This is a summary of Chris Beams’ post on “How to Write a Git Commit Message” for the purpose of being my quick reference. (As Chris mentions: “This has all been said before” - see his references.) Guidelines Separate subject from body with a blank line Limit the subject line to 50 characters, with hard limit at 72 Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why vs. how]]></summary></entry><entry><title type="html">ActiveRecord vs Sequel Performance</title><link href="http://hmistry.github.io/software/2017/12/11/activerecord-vs-sequel.html" rel="alternate" type="text/html" title="ActiveRecord vs Sequel Performance" /><published>2017-12-11T00:00:00+00:00</published><updated>2017-12-11T00:00:00+00:00</updated><id>http://hmistry.github.io/software/2017/12/11/activerecord-vs-sequel</id><content type="html" xml:base="http://hmistry.github.io/software/2017/12/11/activerecord-vs-sequel.html"><![CDATA[<p>I ran some benchmarking tests to evaluate the performance difference, if any, between ActiveRecord and Sequel ORM’s - two common ORM’s in the Ruby world. I measured two sets of benchmarks: speed, and memory consumed. In addition, each set was measured against two different databases: SQLite3, and PostgreSQL. The results are summarized below.
<!--more--></p>

<p id="updated-note"><strong>Updated:</strong> (2017-12-27) I updated the benchmarks to account for ActiveRecord lazily typecasting data on attribute access and Sequel typecasting immediately on retrieval from the database. For an apples-to-apples comparison, the benchmarks now force ActiveRecord to typecast the data so the total computation time and memory used is accounted for in the results for both ORM’s. I also added a set of benchmarks for Sequel with <code class="language-plaintext highlighter-rouge">sequel_pg</code> gem for PostgreSQL database - the <code class="language-plaintext highlighter-rouge">sequel_pg</code> gem replaces the Sequel postgres adapter row fetching and typecasting code with a C version that improves the performance.</p>
<p><br /></p>
<h4 id="contents">Contents:</h4>
<ul>
  <li><a href="#setup">Setup</a></li>
  <li><a href="#results">Results</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<p><br /></p>
<h2 id="setup">Setup</h2>
<ol>
  <li>All the tests were done on a local machine (2013 MacBook Pro) i.e. both the database and ruby script ran on the same machine for simplicity and time.</li>
  <li>Versions used: Ruby v2.4.2, ActiveRecord v5.1.4, Sequel v5.2.0, SQLite v3.16.0, and PostgreSQL v9.6.5.</li>
  <li>Used <code class="language-plaintext highlighter-rouge">benchmark-ips</code> and <code class="language-plaintext highlighter-rouge">memory_profiler</code> gems to obtain performance measurements.</li>
  <li>Ran the test on SQLite3 and PostgreSQL databases.</li>
  <li>The database schema had 3 models - Topic, Post, and Comment - with the following relations - topic has many posts and post has many comments. The database was seeded with 10 topics, 100 posts, and 20,000 comments.</li>
  <li>Both ORM’s were configured to write a log file like in a real world application. Logging did affect the speed - made it slower.</li>
  <li>Benchmark code is available on Github <a href="https://github.com/hmistry/ar_sql">here</a>.</li>
  <li>The tests are grouped as follows:
    <ol>
      <li>Loading the ORM</li>
      <li>Creating records</li>
      <li>Updating records</li>
      <li>Querying records</li>
      <li>Queries - Lazy typecasting &amp; Timestamps</li>
    </ol>
  </li>
</ol>

<p><br /></p>
<h2 id="results">Results:</h2>
<p>Things to note:</p>
<ul>
  <li>Speed performance - results are shown for both PostgreSQL and SQLite3 databases.</li>
  <li>Speed is measured in iterations per second, except load time which is in seconds. Higher is better for iterations per second and lower is better for seconds (load time).</li>
  <li>Memory usage performance - only results for PostgreSQL are shown because results for SQLite3 were very similar and did not offer much insights.</li>
  <li>Memory is measured in bytes and number of objects for memory allocated and retained (total of 4 measurements). Lower is better for memory allocation and retention.</li>
</ul>

<p><strong>Key:</strong><br />
AR =&gt; ActiveRecord gem v5.1.4<br />
Sql =&gt; Sequel gem v5.2.0<br />
Sql + sql_pg =&gt; Sequel gem v5.2.0 + Sequel_pg gem v1.8.1 (for PostgreSQL database only)<br /></p>

<p><br />
<strong>Tests:</strong><br /></p>
<ol>
  <li><a href="#loading">Loading the ORM</a></li>
  <li><a href="#creating">Creating records</a></li>
  <li><a href="#updating">Updating records</a></li>
  <li><a href="#querying">Querying records</a></li>
  <li><a href="#typecasting">Queries - Lazy typecasting &amp; Timestamps</a></li>
</ol>

<p><br /></p>
<h3 id="loading">1. Loading the ORM</h3>
<p>Sequel beats ActiveRecord by ~3x in both speed and memory in loading.</p>
<ul>
  <li>It loads in 0.1s vs 0.3s for ActiveRecord.</li>
  <li>It allocates 6Mb in memory vs 20Mb for ActiveRecord.</li>
  <li>It doesn’t defer any memory allocation to the first query run unlike ActiveRecord which defers further memory allocation of 200Kb to the first query run (after require). A typical ActiveRecord query is in the 10’s Kb (in this test scenario).</li>
</ul>

<p><br />
<strong>ORM Load Time</strong></p>

<p><img src="http://hmistry.github.io/assets/images/load-time.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<strong>ORM Memory Usage</strong></p>

<p><img src="http://hmistry.github.io/assets/images/load-mem.png" alt="Load Memory" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/load-obj.png" alt="Load Memory" class="post-halfwidth-image" /></p>

<p><br />
<strong>ActiveRecord First Run Memory Usage</strong>
<br />
The very first use of any ActiveRecord query (after require) allocates more memory than subsequent queries. This does not happen in Sequel.</p>

<p><img src="http://hmistry.github.io/assets/images/init-run-mem.png" alt="First Run Memory" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/init-run-obj.png" alt="First Run Memory" class="post-halfwidth-image" /></p>

<p><br /></p>
<h3 id="creating">2. Creating records</h3>
<p>Measured two aspects in creating a record - one without validations and the other with a presence validation.</p>
<ul>
  <li>There is little performance degradation due to the validation but this is a simple validation.</li>
</ul>

<p>Sequel performs better than ActiveRecord in both speed and memory for creating records.</p>
<ul>
  <li>It is 1.8x-2x faster for PostgreSQL and 1.2x faster for SQLite3.</li>
  <li>It’s memory allocation is lower and memory retention is significantly lower than ActiveRecord (see charts).</li>
</ul>

<p><br />
<strong>ORM Speed Performance</strong></p>

<p>Using PostgreSQL:</p>

<p><img src="http://hmistry.github.io/assets/images/create-pg-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/create-val-pg-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
Using SQLite3:</p>

<p><img src="http://hmistry.github.io/assets/images/create-sq3-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/create-val-sq3-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<strong>ORM Memory Usage</strong></p>

<p>Using PostgreSQL:</p>

<p><img src="http://hmistry.github.io/assets/images/create-pg-mem.png" alt="Load Memory" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/create-pg-obj.png" alt="Load Memory" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/create-val-pg-mem.png" alt="Load Memory" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/create-val-pg-obj.png" alt="Load Memory" class="post-halfwidth-image" /></p>

<p><br /></p>
<h3 id="updating">3. Updating records</h3>
<p>Measured two different methods of updating a record - one with a hash argument to update an attribute, and the other used method assignment then save to update the record.</p>
<ul>
  <li>There is little performance difference between the two update methodologies.</li>
</ul>

<p>Sequel performs better than ActiveRecord in both speed and memory for updating records.</p>
<ul>
  <li>It is 1.7x-2x faster.</li>
  <li>It’s memory allocation is less than half of ActiveRecord and memory retention is 6x-8x lower than ActiveRecord.</li>
</ul>

<p><br />
<strong>ORM Speed Performance</strong></p>

<p>Using PostgreSQL:</p>

<p><img src="http://hmistry.github.io/assets/images/update-pg-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/update2-pg-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
Using SQLite3:</p>

<p><img src="http://hmistry.github.io/assets/images/update-sq3-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/update2-sq3-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<strong>ORM Memory Usage</strong></p>

<p>Using PostgreSQL:</p>

<p><img src="http://hmistry.github.io/assets/images/update-pg-mem.png" alt="Load Memory" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/update-pg-obj.png" alt="Load Memory" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/update2-pg-mem.png" alt="Load Memory" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/update2-pg-obj.png" alt="Load Memory" class="post-halfwidth-image" /></p>

<p><br /></p>
<h3 id="querying">4. Querying records</h3>
<p>Querying records revealed some implementation differences in the ORM’s and added some complexity to the benchmarking. For an apples-to-apples comparison, these benchmarks force the ORM’s to typecast the data (if you missed the reason, see the <a href="#updated-note">updated note</a> above). Measured the following methods of querying the database (AR method / Sequel method):</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">#find(id) / #[id]</code></li>
  <li><code class="language-plaintext highlighter-rouge">#findby() / #find()</code></li>
  <li><code class="language-plaintext highlighter-rouge">#where()</code></li>
  <li><code class="language-plaintext highlighter-rouge">#first</code></li>
  <li>Eager load associated model, <code class="language-plaintext highlighter-rouge">#where().includes() / #where().eager()</code> (retrieves 1 + 100 records)</li>
  <li><code class="language-plaintext highlighter-rouge">#where().order()</code> query (retrieves 50 records)</li>
</ul>

<p>Sequel generally performed better than ActiveRecord in both speed and memory except for one query.</p>
<ul>
  <li>It is 1.1x-2x faster without <code class="language-plaintext highlighter-rouge">sequel_pg</code> except for one query where it is 20% slower.</li>
  <li>It’s memory allocation and retention is less than ActiveRecord in all but one query.</li>
  <li>Sequel with <code class="language-plaintext highlighter-rouge">sequel_pg</code> is 1.6x-3.8x faster than ActiveRecord.</li>
  <li>Sequel with <code class="language-plaintext highlighter-rouge">sequel_pg</code> is significantly lower in memory allocation and has similar, if not same, memory retention as sequel.</li>
</ul>

<p><br />
<strong>ORM Speed Performance</strong></p>

<p>Using PostgreSQL:</p>

<p><img src="http://hmistry.github.io/assets/images/find-pg-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/findby-pg-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/where-pg-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/first-pg-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/eager-pg-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/postwo-pg-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
SQLite3 Results shown in next <a href="#typecasting">section #5</a>.</p>

<p><br />
<strong>ORM Memory Usage</strong></p>

<p>Using PostgreSQL:</p>

<p><img src="http://hmistry.github.io/assets/images/find-pg-mem.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/find-pg-obj.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/findby-pg-mem.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/findby-pg-obj.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/where-pg-mem.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/where-pg-obj.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/first-pg-mem.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/first-pg-obj.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/eager-pg-mem.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/eager-pg-obj.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/postwo-pg-mem.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/postwo-pg-obj.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br /></p>
<h3 id="typecasting">5. Queries - Lazy typecasting &amp; Timestamps</h3>
<p>These benchmarks explore:</p>
<ul>
  <li>ActiveRecord’s defered typecasting gain/impact on performance (measured the same queries as above - only SQLite3 ones are shown here).</li>
  <li>Typecasting timestamps are slow and is the cause of Sequel slower performance in the one query above.</li>
</ul>

<p>Lazy typecasting gain/impact:</p>
<ul>
  <li>Sequel has the same performance whether you force typecasting through attribute access or not.</li>
  <li>ActiveRecord shows a 10-50% reduction in speed due to deferred typecasting when you access the attribute data.</li>
  <li>It is interesting that even with this optimization, ActiveRecord still looses to Sequel in some queries.</li>
</ul>

<p>Retrieving timestamps impact:</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">#where().order()</code> query performance without retrieving timestamp data increases 1.9x for ActiveRecord and 5.8x for Sequel.</li>
  <li>The <code class="language-plaintext highlighter-rouge">#where().order()</code> query performance of retrieving the timestamp data only (nothing else) is close to retrieving the full record data for both ORM’s.</li>
  <li>This shows that the low performance of <code class="language-plaintext highlighter-rouge">#where().order()</code> query is correlated to retrieving timestamp data for the 50 records.</li>
</ul>

<p><br />
<strong>ORM query performance</strong></p>

<p>Using SQLite3:</p>

<p><img src="http://hmistry.github.io/assets/images/find-sq3-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/findby-sq3-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/where-sq3-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/first-sq3-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/eager-sq3-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/postwo-sq3-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br />
<strong>Timestamps performance cost in <code class="language-plaintext highlighter-rouge">#where().order()</code> query</strong></p>

<p><br />
<img src="http://hmistry.github.io/assets/images/postwo-sq3-ips.png" alt="Load Time" class="post-halfwidth-image post-halfwidth-image-left" />
<img src="http://hmistry.github.io/assets/images/postwo2-sq3-ips.png" alt="Load Time" class="post-halfwidth-image" /></p>

<p><br /></p>
<h2 id="conclusion">Conclusion:</h2>
<p>Summarizing the benchmark results:</p>
<ul>
  <li>In loading, Sequel beats ActiveRecord by ~3x in speed and memory.</li>
  <li>In creating new records, Sequel performs 1.2x-2x better than ActiveRecord in speed and uses less memory.</li>
  <li>In updating records, Sequel performs 1.7x-2x better than ActiveRecord in speed and uses less than half the memory.</li>
  <li>In querying:
    <ul>
      <li>Sequel without <code class="language-plaintext highlighter-rouge">sequel_pg</code> is 1.1x-2x faster than ActiveRecord except for one query where it is 20% slower.</li>
      <li>Sequel memory allocation and retention is less than ActiveRecord in all but one query.</li>
      <li>Sequel with <code class="language-plaintext highlighter-rouge">sequel_pg</code> is 1.6x-3.8x faster than ActiveRecord.</li>
      <li>Sequel with <code class="language-plaintext highlighter-rouge">sequel_pg</code> is significantly lower in memory allocation and has similar, if not same, memory retention as sequel (which is lower than ActiveRecord).</li>
      <li>Retrieving timestamp data can impact speed performance significantly for both ORM’s.</li>
    </ul>
  </li>
</ul>

<p>In conclusion, the overall performance of Sequel is much better than ActiveRecord both in speed and memory usage by a good margin. The lower memory usage also helps to reduce garbage collection overhead in an application. I liked the fact Sequel does not defer some object allocation when loading the library, and it immediately typecasts the data on retrieval when querying. This means once the query is executed, the data is ready for consumption. A side note on querying - typecasting timestamps are slow so consider excluding it when retrieving records from the database for performance critical queries. Lastly, I was quite impressed with the significant performance boost of Sequel with the <code class="language-plaintext highlighter-rouge">sequel_pg</code> addon used with PostgreSQL databases - it’s definitely a must use addon, especially when the only thing you have to do is add it to the <code class="language-plaintext highlighter-rouge">Gemfile</code>!</p>]]></content><author><name></name></author><category term="software" /><category term="ruby" /><category term="gems" /><category term="performance" /><summary type="html"><![CDATA[I ran some benchmarking tests to evaluate the performance difference, if any, between ActiveRecord and Sequel ORM’s - two common ORM’s in the Ruby world. I measured two sets of benchmarks: speed, and memory consumed. In addition, each set was measured against two different databases: SQLite3, and PostgreSQL. The results are summarized below.]]></summary></entry><entry><title type="html">Cleaning Xcode files</title><link href="http://hmistry.github.io/software/2017/10/09/cleaning-xcode-files.html" rel="alternate" type="text/html" title="Cleaning Xcode files" /><published>2017-10-09T00:00:00+00:00</published><updated>2017-10-09T00:00:00+00:00</updated><id>http://hmistry.github.io/software/2017/10/09/cleaning-xcode-files</id><content type="html" xml:base="http://hmistry.github.io/software/2017/10/09/cleaning-xcode-files.html"><![CDATA[<p>This is a summary from the following articles on recovering disk space from Xcode:</p>
<ol>
  <li><a href="http://ajithrnayak.com/post/95441624221/xcode-users-can-free-up-space-on-your-mac">Xcode users can free up space on your Mac by Ajith Nayak</a></li>
  <li><a href="http://blog.neverthesamecolor.net/how-to-recover-disk-space-from-xcode/">How To Recover Disk Space From Xcode by Sascha Holesch</a></li>
</ol>

<p><br /></p>
<h4 id="1-derived-data">1. Derived Data</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Developer/Xcode/DerivedData/</code>
<br />
<strong>Purpose:</strong> Contains data about the projects which includes index, build output, debug/release built targets, and logs. Data can be recreated.
<br />
<!--more-->
<strong>Delete:</strong> Safe to delete. Can be done through Xcode Projects or in Finder by deleting the folders of projects no longer needed.</p>

<p><br /></p>
<h4 id="2-archives">2. Archives</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Developer/Xcode/Archives/</code>
<br />
<strong>Purpose:</strong> Project targets created for beta testing or App Store submissions are archived. The dSYM data is crucial for debugging crash reports.
<br />
<strong>Delete:</strong> Not safe to delete if you need the dSYM data. Can be done through Xcode Organizer or in Finder by deleting the folders of projects no longer needed - be sure to only delete if you don’t need the dSYM data.</p>

<p><br /></p>
<h4 id="3-ios-device-support">3. iOS Device Support</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Developer/Xcode/iOS DeviceSupport/</code>
<br />
<strong>Purpose:</strong> Contains data stored for every device with every iOS version combination used in development. Initial device connection takes longer to copy all this info. Data can be recreated by connecting device to Mac.
<br />
<strong>Delete:</strong> Safe to delete. Use Finder to delete the folders of device with iOS version no longer needed.</p>

<p><br /></p>
<h4 id="4-core-simulator">4. Core Simulator</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Developer/Xcode/CoreSimulator/Devices/</code>
<br />
<strong>Purpose:</strong> Contains simulators for each version of iOS + device and represented by UUID’s which can be deciphered using the file <code class="language-plaintext highlighter-rouge">.default_created.plist</code>.
<br />
<strong>Delete:</strong> Safe to delete. Can be done through Xcode Projects or in Finder by deleting the folders of projects no longer needed.</p>

<p><br /></p>
<h4 id="5-documentation">5. Documentation</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Developer/Shared/Documentation/DocSets/</code>
<br />
<strong>Purpose:</strong> Contains documentation sets stored for Xcode.
<br />
<strong>Delete:</strong> Safe to delete. Delete file in Finder.</p>

<p><br /></p>
<h4 id="6-cache">6. Cache</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Caches/com.apple.dt.Xcode</code>
<br />
<strong>Purpose:</strong> Some kind of Xcode cache in form of a packaged file. File size is relatively small.
<br />
<strong>Delete:</strong> Safe to delete. Delete file in Finder.</p>

<p><br /></p>
<h4 id="7-device-backup">7. Device Backup</h4>
<p><strong>Location:</strong> <code class="language-plaintext highlighter-rouge">~/Library/Application Support/MobileSync/Backup/</code>
<br />
<strong>Purpose:</strong> Contains a backup sync data of some files and settings of an iOS device that was connected to Mac. This maybe a legacy thing because it’s related to iTunes mobile device sync. Needs verification.
<br />
<strong>Delete:</strong> Safe to delete through iTunes device section in preference if you don’t need it.</p>]]></content><author><name></name></author><category term="software" /><category term="xcode" /><summary type="html"><![CDATA[This is a summary from the following articles on recovering disk space from Xcode: Xcode users can free up space on your Mac by Ajith Nayak How To Recover Disk Space From Xcode by Sascha Holesch 1. Derived Data Location: ~/Library/Developer/Xcode/DerivedData/ Purpose: Contains data about the projects which includes index, build output, debug/release built targets, and logs. Data can be recreated.]]></summary></entry><entry><title type="html">Hello Universe!</title><link href="http://hmistry.github.io/misc/2017/10/01/hello-universe.html" rel="alternate" type="text/html" title="Hello Universe!" /><published>2017-10-01T00:00:00+00:00</published><updated>2017-10-01T00:00:00+00:00</updated><id>http://hmistry.github.io/misc/2017/10/01/hello-universe</id><content type="html" xml:base="http://hmistry.github.io/misc/2017/10/01/hello-universe.html"><![CDATA[<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="nb">puts</span> <span class="s2">"Hello Universe!"</span></code></pre></figure>

<p>Stay tuned… 😃</p>

<p><em>Message posted 8 years and 3 months ago</em></p>]]></content><author><name></name></author><category term="misc" /><category term="misc" /><summary type="html"><![CDATA[puts "Hello Universe!" Stay tuned… 😃 Message posted 8 years and 3 months ago]]></summary></entry></feed>